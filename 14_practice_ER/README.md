## check制約とは

- カラムに対してcheck制約を設定すると、追加するデータに対する条件(ロジック)を設定することができる
- データ挿入時に条件を満たさなかったらエラーにな

```
CREATE TABLE hoge(
	hoge data_type CHECK(expression)
)

CREATE TABLE users(
   name VARCHAR(20)
	 sex  VARCHAR(10)
  
   CONSTRAINT sexcheck CHECK(sex in('男性', '女性'))
)
```
## check制約のデメリット

- 強すぎる制約はダメ
- 日時や値に範囲(レンジ)があるもの対しては導入しないこと
- 例えば下記のようにupdate_atにcheck制約を用いるとテストデータが導入できなかったり、restoreできなかったりする

```
//これだとテストデータ入れれない、restoreできない。
CREATE TABLE (
	update_at DATETIME 
  CONSTRAINT update_at_check　CHECK(update_at >= now())
)
```

## domain制約とは

- 特定のカラムに対して独自の型を作成することができる
- 下記見たく作成できるらしい

```
DROP DOMAIN IF EXISTS test_status_kbn CASCADE;
CREATE DOMAIN test_status_kbn TEXT
CONSTRAINT check_test_status_kbn CHECK (
  VALUE IN (
    '10101' -- テスト状態区分(未テスト)
    ,'10102' -- テスト状態区分(テスト中)
    ,'10103' -- テスト状態区分(テスト済み)
  )
);
```
[こんな感じで作るらしい](https://nuko-yokohama.hatenadiary.org/entry/20111210/1323463137)

## domein制約のデメリット

- ドメイン制約で持ちうる値がDB定義を見ないとわからない
- 変更するのみalter tableしないといけないから変更容易性が損なわれる

## Emun型

- 予め挿入する値を列挙するパターンの制約
```
CREATE TABLE Users (
    user_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    user_role ENUM ('admin', 'member'),
    PRIMARY KEY (user_id)
)
```

## Emun型のデメリット

- domein制約でも同じ

## モデリング時に制約を早期に持たせると、拡張性や柔軟性を損ねる

- sqlアンチパターンのサーティワンフレーバーでも紹介されている
- そもそもこいった制約は各種データベースで仕様が統一されていない
- 制約の変更を使用としたときに、コストが高い。
    - Enumで列挙した値を男性からmanに変更したい時、manの制約を追加→男性で値挿入されているデータを全てmanに書き換え→男性制約の削除
- 留意すべき制約の強度
    - 強い制約
        - check制約などを用いいてデータベースに依存しているが、データを守るためのデットラインが明確になっていること、例えば都道府県とか。そもそも世の中に普遍的に定義されているデータ数などはcheck制約などを用いいても大丈夫
    - 強すぎる制約
        - 制約の内容がシステムの内容やビジネスルールに基づいて記述されている状態
    
    この強すぎる制約になっていないかを考えることが大切というか、ドメインに関する値は値オブジェクトなどで値の正確さを担保しようね。

## トリガー

- あるテーブルにinsert, updateされたら、関連テーブルにinsertやupdateを行う処理
- 下記はinsertすると発火するトリガー、参考にまで
```
CREATE TRIGGER insert_log AFTER INSERT ON users
FOR EACH ROW
  INSERT INTO event_logs (table, action, user_id) VALUES ("users", "INSERT", NEW.id);
```

## トリガーのデメリット

- そもそもトリガーで実装する内容はビジネスロジックに依存しているため、**開発者がトリガーの存在を知らなければ想定外の挙動になってしまう。**

## トリガーは隠れた状態を持つことになる

- サーティワンフレーバーと一緒で状態を保つことでかえって複雑性を増す
- ほんとにメリットが著しく認めらると考えられた場合のみ導入すること、少しメリットがあるかなの気持ちでは導入は決してしないこと

## トリガーのuse case

- ビジネスロジックに紐ずかないlogや履歴を保存するとき。ビジネスロジックとはイベント系のモデルのことをさす
- データ移行やレプリケーション機能

##　課題１
- 基本的にDB側の制約やトリガーは使わない方がいい
- enum制約は相互排他的な２つの値を指定する場合
    - 例:左/右、有効/無効、オン/オフ、内部/外部みたいな値で原的な場合
- check制約は世の中で必ず決まりがある概念など
    - 例：都道府県数など
- domain制約を使うメリットはenum同様かな
- トリガー：イベントログを種々したい時に活用する(ドメインルールに紐付いていない),操作ログなど

## 課題２
- トリガーはECサイトのテーブル構造にて、商品を購入したタイミングで注文テーブルにinsertされて発送テーブルでステータスを挿入する場合があるときにアンチパターンに陥りそう
     - 商品購入-> 発送準備中といったフロー
- domain制約は注文テーブルにインサートする時の住所入力時
    - 例えば会員ではないが、商品注文する際に住所を入力するとか
- enum制約は会員登録する際の性別など, その他ステータス、区分などのデータ
- check制約は会員登録に特定の年齢レンジが存在する場合にアンチパターンに陥る
    - 20 ~ 60歳が対象者とか、保険のアプリケーションなど


## まとめ
- ビジネスロジックはアプリケーション側で持つこと、強すぎる制約(check制約など)そもそもDBの責務違反であり、事実を記録するに反している。
